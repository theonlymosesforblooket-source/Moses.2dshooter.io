<!DOCTYPE html>
<html>
<head>
<title>Zombie Arena 3D</title>
<meta http-equiv="Permissions-Policy" content="interest-cohort=()">
<style>
* { margin:0; padding:0; }
html, body { width:100%; height:100%; overflow:hidden; background:#000; font:14px monospace; cursor:none; }
canvas { display:block; width:100vw; height:100vh; }

#ui {
    position:fixed; top:10px; left:10px; color:#0ff;
    background:rgba(0,0,0,0.8); padding:10px; border-radius:5px;
    z-index:100;
}
#crosshair {
    position:fixed;
    top:50%; left:50%;
    width:20px; height:20px;
    transform:translate(-50%,-50%);
    pointer-events:none;
    z-index:100;
}
#crosshair::before,
#crosshair::after {
    content:"";
    position:absolute;
    background:#0ff;
}
#crosshair::before {
    width:2px;
    height:20px;
    left:50%;
    top:0;
    transform:translateX(-50%);
}
#crosshair::after {
    width:20px;
    height:2px;
    top:50%;
    left:0;
    transform:translateY(-50%);
}
#upgradeMenu {
    display:none;
    position:fixed;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:#000; color:#0ff;
    padding:25px; border:2px solid #0ff;
    z-index:200; text-align:center;
}
button {
    margin:10px; padding:10px 20px;
    font-size:16px; cursor:pointer;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/js/postprocessing/RenderPass.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/js/postprocessing/ShaderPass.js"></script>
</head>
<body>

<div id="ui">
Round: <span id="round">1</span> |
Kills: <span id="kills">0</span> |
Bullets: <span id="bullets">1</span> |
Reload: <span id="reload">1.50</span>s
</div>

<div id="crosshair"></div>

<div id="upgradeMenu">
<h2>Choose Upgrade</h2>
<button onclick="upgradeBullets()">+1 Bullet</button>
<button onclick="upgradeFireRate()">Faster Reload</button>
</div>

<script>
// SCENE
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000011);

const camera = new THREE.PerspectiveCamera(80, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const WarpShader = {
    uniforms: {
        "tDiffuse": { value: null },
        "strength": { value: 0.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float strength;
        varying vec2 vUv;

        void main() {
            vec2 uv = vUv;
            vec2 center = vec2(0.5, 0.5);
            vec2 delta = uv - center;
            float dist = length(delta);
            float warp = strength * dist * dist * 2.0;
            uv += delta * warp;
            gl_FragColor = texture2D(tDiffuse, uv);
        }
    `
};

const warpPass = new THREE.ShaderPass(WarpShader);
composer.addPass(warpPass);


scene.add(new THREE.AmbientLight(0x666666, 0.4));
const sun = new THREE.DirectionalLight(0xffffff, 0.6);
sun.position.set(50, 50, 50);
scene.add(sun);

// FLOOR
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.MeshBasicMaterial({color:0x112244})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// 3D WALLS
const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x003366 });
let walls3D = [];

function createWall(x, y, z, w, h, d) {
    const wall = new THREE.Mesh(
        new THREE.BoxGeometry(w, h, d),
        wallMaterial
    );
    wall.position.set(x, y, z);
    scene.add(wall);
    walls3D.push(wall);
    return wall;
}

// Simple arena box
createWall(0, 1.25, -50, 200, 2.5, 5);   // North
createWall(0, 1.25, 50, 200, 2.5, 5);    // South
createWall(-50, 1.25, 0, 5, 2.5, 200);   // West
createWall(50, 1.25, 0, 5, 2.5, 200);    // East

// COLLISION HELPERS
const tmpBox = new THREE.Box3();
function collidesWithWall3D(pos, radius = 0.5) {
    for (let wall of walls3D) {
        tmpBox.setFromObject(wall);
        // Expand box slightly by radius
        if (pos.x > tmpBox.min.x - radius &&
            pos.x < tmpBox.max.x + radius &&
            pos.y > tmpBox.min.y - radius &&
            pos.y < tmpBox.max.y + radius &&
            pos.z > tmpBox.min.z - radius &&
            pos.z < tmpBox.max.z + radius) {
            return true;
        }
    }
    return false;
}

// PLAYER STATE
const playerPos = new THREE.Vector3(0,1.7,0);
let yaw = 0, pitch = 0;
let round = 1, kills = 0;
let bulletCount = 1;
let reloadCooldown = 1.5;
let lastShotTime = 0;

let bullets = [];
let zombies = [];
let keys = {};
let upgradeMenuOpen = false;

// POINTER LOCK
renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());
document.addEventListener('mousemove', e => {
    if(document.pointerLockElement){
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    }
});

// INPUT
document.addEventListener('keydown', e => keys[e.code] = true);
document.addEventListener('keyup', e => keys[e.code] = false);

// SHOOT
function shoot(){
    const now = Date.now();
    if(upgradeMenuOpen) return;
    if(now - lastShotTime < reloadCooldown * 1000) return;
    lastShotTime = now;
warpPass.uniforms.strength.value = 0.25;

    const forward = new THREE.Vector3(0,0,-1)
        .applyAxisAngle(new THREE.Vector3(0,1,0), yaw)
        .applyAxisAngle(new THREE.Vector3(1,0,0), pitch)
        .normalize();

    const spread = 0.15;

    for(let i=0;i<bulletCount;i++){
        const bullet = new THREE.Mesh(
            new THREE.SphereGeometry(0.12),
            new THREE.MeshBasicMaterial({color:0xffff44})
        );

        bullet.position.copy(playerPos);

        const offset = (i - (bulletCount - 1) / 2) * spread;
        const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

        const dir = forward.clone().add(right.multiplyScalar(offset)).normalize();

        bullet.userData.vel = dir.multiplyScalar(1.5);
        scene.add(bullet);
        bullets.push(bullet);
    }
}

// ZOMBIES
function spawnZombies(){
    zombies.forEach(z => scene.remove(z));
    zombies = [];

    for(let i=0;i<round+2;i++){
        const z = new THREE.Mesh(
            new THREE.BoxGeometry(1.2,2.5,1.2),
            new THREE.MeshBasicMaterial({color:0x00ff00})
        );
        // spawn inside arena
        z.position.set((Math.random()-0.5)*80,1.25,(Math.random()-0.5)*80);
        // avoid spawning inside walls
        if (collidesWithWall3D(z.position, 1.0)) {
            i--;
            continue;
        }
        scene.add(z);
        zombies.push(z);
    }
}

// UPGRADE MENU
function showUpgradeMenu(){
    upgradeMenuOpen = true;
    document.getElementById("upgradeMenu").style.display="block";
}
function hideUpgradeMenu(){
    upgradeMenuOpen = false;
    document.getElementById("upgradeMenu").style.display="none";
    spawnZombies();
}
function upgradeBullets(){
    bulletCount++;
    hideUpgradeMenu();
}
function upgradeFireRate(){
    reloadCooldown = Math.max(0, reloadCooldown * 0.8);
    hideUpgradeMenu();
}

// GAME LOOP
function loop(){
    requestAnimationFrame(loop);
warpPass.uniforms.strength.value *= 0.92;

    // MOVEMENT
    const speed = 0.25;
    const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
    const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0),yaw);

    let move = new THREE.Vector3();
    if(keys.KeyW) move.add(forward);
    if(keys.KeyS) move.add(forward.clone().multiplyScalar(-1));
    if(keys.KeyA) move.add(right.clone().multiplyScalar(-1));
    if(keys.KeyD) move.add(right);

    if (move.lengthSq() > 0) {
        move.normalize().multiplyScalar(speed);
        const nextPos = playerPos.clone().add(move);
        if (!collidesWithWall3D(nextPos, 0.6)) {
            playerPos.copy(nextPos);
        }
        warpPass.uniforms.strength.value = Math.min(0.15, warpPass.uniforms.strength.value + 0.02);
}

    if(keys.Space) shoot();

    camera.position.copy(playerPos);
    camera.rotation.order='YXZ';
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    // BULLETS
    for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        const nextPos = b.position.clone().add(b.userData.vel);

        // wall hit
        if (collidesWithWall3D(nextPos, 0.2)) {
            scene.remove(b);
            bullets.splice(i,1);
            continue;
        }

        b.position.copy(nextPos);

        if(b.position.length()>120){
            scene.remove(b);
            bullets.splice(i,1);
            continue;
        }

        for(let j=zombies.length-1;j>=0;j--){
            if(b.position.distanceTo(zombies[j].position)<1){
                scene.remove(b);
                scene.remove(zombies[j]);
                bullets.splice(i,1);
                zombies.splice(j,1);
                kills++;
                break;
            }
        }
    }

    // ZOMBIE CHASE
    zombies.forEach(z=>{
        const zSpeed = 0.05 + (round * 0.002);
        const dir = playerPos.clone().sub(z.position).normalize();
        const nextZ = z.position.clone().add(dir.multiplyScalar(zSpeed));

        if (!collidesWithWall3D(nextZ, 0.8)) {
            z.position.copy(nextZ);
        }

        z.rotation.y = Math.atan2(dir.x, dir.z);
if (z.position.distanceTo(playerPos) < 6) {
    warpPass.uniforms.strength.value = Math.min(0.3, warpPass.uniforms.strength.value + 0.03);
}

        if(z.position.distanceTo(playerPos)<1.5){
            alert(`GAME OVER\nRound ${round} | Kills: ${kills}`);
            round=1; kills=0; bulletCount=1; reloadCooldown=1.5;
            spawnZombies();
        }
    });

    // NEXT ROUND
    if(zombies.length===0 && !upgradeMenuOpen){
        round++;
        if(round % 3 === 0) showUpgradeMenu();
        else spawnZombies();
    }

    // UI
    document.getElementById('round').textContent = round;
    document.getElementById('kills').textContent = kills;
    document.getElementById('bullets').textContent = bulletCount;
    document.getElementById('reload').textContent = reloadCooldown.toFixed(2);

composer.render();
}

spawnZombies();
loop();
</script>
</body>
</html>
