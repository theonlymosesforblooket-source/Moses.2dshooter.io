<!DOCTYPE html>
<html>
<head>
<title> Zombie Arena</title>

<meta http-equiv="Permissions-Policy" content="interest-cohort=()">

<style>
* { margin:0; padding:0; }
html, body { width:100%; height:100%; overflow:hidden; background:#000; font:14px monospace; cursor:none; }
canvas { display:block; width:100vw; height:100vh; }

#ui {
    position:fixed; top:10px; left:10px; color:#0ff;
    background:rgba(0,0,0,0.8); padding:10px; border-radius:5px;
    z-index:100;
}
#crosshair {
    position:fixed;
    top:50%; left:50%;
    width:20px; height:20px;
    transform:translate(-50%,-50%);
    pointer-events:none;
    z-index:100;
}

#crosshair::before,
#crosshair::after {
    content:"";
    position:absolute;
    background:#0ff;
}

#crosshair::before {
    width:2px;
    height:20px;
    left:50%;
    top:0;
    transform:translateX(-50%);
}

#crosshair::after {
    width:20px;
    height:2px;
    top:50%;
    left:0;
    transform:translateY(-50%);
}

}
#upgradeMenu {
    display:none;
    position:fixed;
    top:50%; left:50%;
    transform:translate(-50%,-50%);
    background:#000; color:#0ff;
    padding:25px; border:2px solid #0ff;
    z-index:200; text-align:center;
}
button {
    margin:10px; padding:10px 20px;
    font-size:16px; cursor:pointer;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="ui">
Round: <span id="round">1</span> |
Kills: <span id="kills">0</span> |
Bullets: <span id="bullets">1</span> |
Reload: <span id="reload">1.50</span>s
</div>

<div id="crosshair"></div>

<div id="upgradeMenu">
<h2>Choose Upgrade</h2>
<button onclick="upgradeBullets()">+1 Bullet</button>
<button onclick="upgradeFireRate()">Faster Reload</button>
</div>

<script>
// SCENE
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000011);

const camera = new THREE.PerspectiveCamera(80, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer();
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0x666666, 0.4));
const sun = new THREE.DirectionalLight(0xffffff, 0.6);
sun.position.set(50, 50, 50);
scene.add(sun);

// FLOOR
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(200,200),
    new THREE.MeshBasicMaterial({color:0x112244})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// PLAYER STATE
const playerPos = new THREE.Vector3(0,1.7,0);
let yaw = 0, pitch = 0;
let round = 1, kills = 0;
let bulletCount = 1;
let reloadCooldown = 1.5;
let lastShotTime = 0;

let bullets = [];
let zombies = [];
let keys = {};
let upgradeMenuOpen = false;

// POINTER LOCK
renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());
document.addEventListener('mousemove', e => {
    if(document.pointerLockElement){
        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;
        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
    }
});

// INPUT
document.addEventListener('keydown', e => keys[e.code] = true);
document.addEventListener('keyup', e => keys[e.code] = false);

// SHOOT
function shoot(){
    const now = Date.now();
    if(upgradeMenuOpen) return;
    if(now - lastShotTime < reloadCooldown * 1000) return;
    lastShotTime = now;

    const forward = new THREE.Vector3(0,0,-1)
        .applyAxisAngle(new THREE.Vector3(0,1,0), yaw)
        .applyAxisAngle(new THREE.Vector3(1,0,0), pitch)
        .normalize();

    const spread = 0.15; // horizontal spacing for multi-shot

    for(let i=0;i<bulletCount;i++){
        const bullet = new THREE.Mesh(
            new THREE.SphereGeometry(0.12),
            new THREE.MeshBasicMaterial({color:0xffff44})
        );

        bullet.position.copy(playerPos);

        // horizontal offset only (no randomness)
        const offset = (i - (bulletCount - 1) / 2) * spread;
        const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

        const dir = forward.clone().add(right.multiplyScalar(offset)).normalize();

        bullet.userData.vel = dir.multiplyScalar(1.5);
        scene.add(bullet);
        bullets.push(bullet);
    }
}


// ZOMBIES
function spawnZombies(){
    zombies.forEach(z => scene.remove(z));
    zombies = [];

    for(let i=0;i<round+2;i++){
        const z = new THREE.Mesh(
            new THREE.BoxGeometry(1.2,2.5,1.2),
            new THREE.MeshBasicMaterial({color:0x00ff00})
        );
        z.position.set((Math.random()-0.5)*70,1.25,(Math.random()-0.5)*70);
        scene.add(z);
        zombies.push(z);
    }
}

// UPGRADE MENU
function showUpgradeMenu(){
    upgradeMenuOpen = true;
    document.getElementById("upgradeMenu").style.display="block";
}
function hideUpgradeMenu(){
    upgradeMenuOpen = false;
    document.getElementById("upgradeMenu").style.display="none";
    spawnZombies();
}
function upgradeBullets(){
    bulletCount++;
    hideUpgradeMenu();
}
function upgradeFireRate(){
    reloadCooldown = Math.max(0, reloadCooldown * 0.8);
    hideUpgradeMenu();
}

// GAME LOOP
function loop(){
    requestAnimationFrame(loop);

    // MOVEMENT
    const speed = 0.25;
    const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(new THREE.Vector3(0,1,0),yaw);
    const right = new THREE.Vector3(1,0,0).applyAxisAngle(new THREE.Vector3(0,1,0),yaw);

    if(keys.KeyW) playerPos.add(forward.clone().multiplyScalar(speed));
    if(keys.KeyS) playerPos.add(forward.clone().multiplyScalar(-speed));
    if(keys.KeyA) playerPos.add(right.clone().multiplyScalar(-speed));
    if(keys.KeyD) playerPos.add(right.clone().multiplyScalar(speed));
    if(keys.Space) shoot();

    camera.position.copy(playerPos);
    camera.rotation.order='YXZ';
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    // BULLETS
    for(let i=bullets.length-1;i>=0;i--){
        const b = bullets[i];
        b.position.add(b.userData.vel);

        if(b.position.length()>100){
            scene.remove(b);
            bullets.splice(i,1);
            continue;
        }

        for(let j=zombies.length-1;j>=0;j--){
            if(b.position.distanceTo(zombies[j].position)<1){
                scene.remove(b);
                scene.remove(zombies[j]);
                bullets.splice(i,1);
                zombies.splice(j,1);
                kills++;
                break;
            }
        }
    }

    // ZOMBIE CHASE
    zombies.forEach(z=>{
        const zSpeed = 0.05 + (round * 0.002);
        const dir = playerPos.clone().sub(z.position).normalize();
        z.position.add(dir.multiplyScalar(zSpeed));
        z.rotation.y = Math.atan2(dir.x, dir.z);

        if(z.position.distanceTo(playerPos)<1.5){
            alert(`GAME OVER\nRound ${round} | Kills: ${kills}`);
            round=1; kills=0; bulletCount=1; reloadCooldown=1.5;
            spawnZombies();
        }
    });

    // NEXT ROUND
    if(zombies.length===0 && !upgradeMenuOpen){
        round++;
        if(round % 3 === 0) showUpgradeMenu();
        else spawnZombies();
    }

    // UI
    document.getElementById('round').textContent = round;
    document.getElementById('kills').textContent = kills;
    document.getElementById('bullets').textContent = bulletCount;
    document.getElementById('reload').textContent = reloadCooldown.toFixed(2);

    renderer.render(scene, camera);
}

spawnZombies();
loop();
</script>
</body>
</html>
