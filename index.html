<!DOCTYPE html>
<html>
<head>
    <title>Zombie Arena 3D</title>
    <style>
        body { margin:0; overflow:hidden; background:#111; }
        canvas { display:block; }
        #ui-overlay {
            position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
            background:rgba(0,0,0,0.95); border:3px solid #0066CC; padding:40px;
            text-align:center; color:white; display:none; z-index:10;
        }
        .btn { background:#0066CC; color:white; border:none; padding:15px 30px; margin:10px; cursor:pointer; font-size:18px; }
        .btn:hover { background:#0088ff; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
</head>
<body>
    <div id="ui-overlay">
        <h1 id="menu-title">UPGRADE MENU</h1>
        <p id="menu-text">SELECT UPGRADE:</p>
        <button class="btn" id="upgrade-bullets">+1 BULLET</button>
        <button class="btn" id="upgrade-speed">FASTER RELOAD</button>
    </div>

    <script>
        // ---------- THREE.JS SETUP ----------
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111111);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // ---------- GAME STATE (same as before) ----------
        const DEFAULTS = { bulletCount:1, shootCooldown:1500, round:1 };
        let permBulletBonus = 0, permReloadBonus = 1, permanentChosen = false;
        let gameActive = true, round = 1, zombiesKilled = 0, bulletCount = 1, shootCooldown = 1500;
        let bullets = [], enemies = [], lastShotTime = 0, zombieSpeedBonus = 0;
        let keys = {}, mouse = {x:0, y:0};

        // ---------- 3D PLAYER ----------
        const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
        const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x00cccc });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.set(0, 0.5, 0);
        scene.add(player);

        // ---------- WALLS (3D) ----------
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x0066cc });
        const walls = [];
        function createWalls() {
            // Clear old walls
            walls.forEach(w => scene.remove(w));
            walls.length = 0;
            
            const arenaSize = 40;
            const wallHeight = 3;
            const wallThickness = 2;
            
            // Four corner walls
            const wallPositions = [
                {x: -arenaSize/2, z: -arenaSize/2, rotationY: 0},   // Top
                {x:  arenaSize/2, z: -arenaSize/2, rotationY: 0},   // Top right gap
                {x: -arenaSize/2, z:  arenaSize/2, rotationY: 0},   // Bottom
                {x:  arenaSize/2, z:  arenaSize/2, rotationY: 0},   // Bottom right gap
            ];
            
            wallPositions.forEach(pos => {
                const wall = new THREE.Mesh(
                    new THREE.BoxGeometry(wallThickness, wallHeight, arenaSize),
                    wallMaterial
                );
                wall.position.set(pos.x, wallHeight/2, pos.z);
                wall.rotation.y = pos.rotationY;
                scene.add(wall);
                walls.push(wall);
            });
        }

        // ---------- ZOMBIES & BULLETS ----------
        function createZombie() {
            const geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const zombie = new THREE.Mesh(geometry, material);
            zombie.position.set(
                (Math.random() - 0.5) * 20,
                0.6,
                (Math.random() - 0.5) * 20
            );
            scene.add(zombie);
            return zombie;
        }

        function createBullet() {
            const geometry = new THREE.SphereGeometry(0.1);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(geometry, material);
            scene.add(bullet);
            return bullet;
        }

        // ---------- INPUT ----------
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'Backspace') showUpgradeMenu();
            if(e.code === 'Space') e.preventDefault();
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        // ---------- GAME FUNCTIONS ----------
        function shoot() {
            const now = Date.now();
            if(now - lastShotTime < shootCooldown) return;
            lastShotTime = now;

            const speed = 0.5;
            const baseAngle = Math.atan2(mouse.x, -mouse.y);
            const spread = 0.2 / bulletCount;

            for(let i = 0; i < bulletCount; i++) {
                let angle = baseAngle + (i - (bulletCount - 1) / 2) * spread;
                let bullet = createBullet();
                bullet.position.copy(player.position);
                bullet.userData = {
                    vx: Math.cos(angle) * speed,
                    vy: 0,
                    vz: Math.sin(angle) * speed
                };
                bullets.push(bullet);
            }
        }

        function spawnRound() {
            enemies.forEach(e => scene.remove(e));
            enemies.length = 0;
            let count = 5 + round;
            let zSpeed = 0.02 + (round * 0.002) + zombieSpeedBonus;
            
            for(let i = 0; i < count; i++) {
                let zombie = createZombie();
                zombie.userData.speed = zSpeed;
                enemies.push(zombie);
            }
        }

        function showUpgradeMenu() {
            gameActive = false;
            document.getElementById('ui-overlay').style.display = 'block';
        }

        // UI Event Listeners (same as before)
        document.getElementById('upgrade-bullets').onclick = () => {
            bulletCount++;
            startNextRound();
        };
        document.getElementById('upgrade-speed').onclick = () => {
            shootCooldown *= 0.8;
            startNextRound();
        };

        function startNextRound() {
            document.getElementById('ui-overlay').style.display = 'none';
            gameActive = true;
            round++;
            spawnRound();
        }

        // ---------- UPDATE LOOP ----------
        function update() {
            if(!gameActive) return;

            // Player movement
            const speed = 0.2;
            let moveX = 0, moveZ = 0;
            if(keys['KeyW']) moveZ -= speed;
            if(keys['KeyS']) moveZ += speed;
            if(keys['KeyA']) moveX -= speed;
            if(keys['KeyD']) moveX += speed;

            player.position.x += moveX;
            player.position.z += moveZ;

            if(keys['Space']) shoot();

            // Update camera (top-down follow)
            camera.position.set(player.position.x, 25, player.position.z - 15);
            camera.lookAt(player.position);

            // Update bullets
            for(let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];
                b.position.x += b.userData.vx;
                b.position.z += b.userData.vz;
                
                if(b.position.length() > 50) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                    continue;
                }

                // Bullet-enemy collision
                for(let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if(b.position.distanceTo(e.position) < 0.8) {
                        scene.remove(b); scene.remove(e);
                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        zombiesKilled++;
                        break;
                    }
                }
            }

            // Update enemies
            enemies.forEach(e => {
                let dx = player.position.x - e.position.x;
                let dz = player.position.z - e.position.z;
                let dist = Math.sqrt(dx*dx + dz*dz);
                e.position.x += (dx / dist) * e.userData.speed;
                e.position.z += (dz / dist) * e.userData.speed;

                // Collision
                if(e.position.distanceTo(player.position) < 1) {
                    // Reset game
                    round = 1; zombiesKilled = 0; bulletCount = 1; shootCooldown = 1500;
                    bullets.forEach(b => scene.remove(b)); bullets.length = 0;
                    enemies.forEach(e => scene.remove(e)); enemies.length = 0;
                    spawnRound();
                }
            });

            // Check win round
            if(enemies.length === 0) {
                round++;
                spawnRound();
            }
        }

        // ---------- RENDER LOOP ----------
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }

        // Init
        createWalls();
        spawnRound();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
