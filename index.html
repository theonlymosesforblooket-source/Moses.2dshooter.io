<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Zombie Arena: Infinite Scaling</title>
<style>
body, html { margin:0; padding:0; overflow:hidden; background:#111; font-family: Courier New, monospace; }
canvas { display:block; cursor: crosshair; width:100vw; height:100vh; }
#ui-overlay {
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
    background:rgba(0,0,0,0.95); border:3px solid #0066CC; padding:40px;
    text-align:center; color:white; display:none; z-index:10; box-shadow:0 0 20px #0066CC;
}
.btn {
    background:#0066CC; color:white; border:none; padding:15px 30px;
    margin:10px; cursor:pointer; font-size:18px; font-weight:bold; border-radius:5px;
}
.btn:hover { background:#0088ff; transform:scale(1.05); }
h1 { color:#ff3333; margin-top:0; }
</style>
</head>
<body>

<div id="ui-overlay">
<h1 id="menu-title">UPGRADE MENU</h1>
<p id="menu-text">SELECT UPGRADE:</p>
<button class="btn" id="upgrade-bullets">+1 BULLET</button>
<button class="btn" id="upgrade-speed">FASTER RELOAD</button>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const ui = document.getElementById('ui-overlay');

// ---------- DEFAULTS ----------
const DEFAULTS = { bulletCount:1, shootCooldown:1500, round:1 };

// ---------- PERMANENT UPGRADES ----------
let permBulletBonus = 0;
let permReloadBonus = 1;
let permanentChosen = false;
let zombieSpeedBonus = 0;

// ---------- GAME STATE ----------
let gameActive = true;
let round = DEFAULTS.round;
let zombiesKilled = 0;
let bullets = [];
let enemies = [];
let isPermanentMenu = false;
let lastShotTime = 0;

const ZOMBIE_SPAWN = { x:80, y:80 };
let player = { x:400, y:300, angle:0, speed:100000000000000000000000000000000, size:10 };
let bulletCount = DEFAULTS.bulletCount;
let shootCooldown = DEFAULTS.shootCooldown;

// ---------- WALLS ----------
const WALL_THICK = 25;
const HOLE_WIDTH = 130;
let walls = [];

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.imageSmoothingEnabled = false;
    createWalls();
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;
}

function createWalls(){
    const w = canvas.width;
    const h = canvas.height;
    walls = [
        { x:0, y:40, width:(w/2)-(HOLE_WIDTH/2), height:WALL_THICK },
        { x:(w/2)+(HOLE_WIDTH/2), y:40, width:(w/2)-(HOLE_WIDTH/2), height:WALL_THICK },
        { x:0, y:h-40-WALL_THICK, width:(w/2)-(HOLE_WIDTH/2), height:WALL_THICK },
        { x:(w/2)+(HOLE_WIDTH/2), y:h-40-WALL_THICK, width:(w/2)-(HOLE_WIDTH/2), height:WALL_THICK },
        { x:40, y:0, width:WALL_THICK, height:(h/2)-(HOLE_WIDTH/2) },
        { x:40, y:(h/2)+(HOLE_WIDTH/2), width:WALL_THICK, height:(h/2)-(HOLE_WIDTH/2) },
        { x:w-40-WALL_THICK, y:0, width:WALL_THICK, height:(h/2)-(HOLE_WIDTH/2) },
        { x:w-40-WALL_THICK, y:(h/2)+(HOLE_WIDTH/2), width:WALL_THICK, height:(h/2)-(HOLE_WIDTH/2) }
    ];
}

function collidesWithWall(x, y, size) {
    for(let wall of walls) {
        if(x-size < wall.x+wall.width+1 &&
           x+size > wall.x-1 &&
           y-size < wall.y+wall.height+1 &&
           y+size > wall.y-1) {
            return true;
        }
    }
    return false;
}

function wrapEntity(entity) {
    if(entity.x < 0) entity.x = canvas.width;
    if(entity.x > canvas.width) entity.x = 0;
    if(entity.y < 0) entity.y = canvas.height;
    if(entity.y > canvas.height) entity.y = 0;
}

// ---------- INPUT ----------
let mouse = {x:0, y:0};
let keys = {};

window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    
    if(e.key === 'Backspace') {
        e.preventDefault();
        showUpgradeMenu();
    }
    
    if(e.code === 'Space') e.preventDefault();
});
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

function showUpgradeMenu() {
    gameActive = false;
    isPermanentMenu = false;
    document.getElementById('menu-title').innerText = 'UPGRADE MENU';
    document.getElementById('menu-text').innerText = 'SELECT UPGRADE:';
    ui.style.display = 'block';
}

document.getElementById('upgrade-bullets').addEventListener('click', () => {
    if(isPermanentMenu) applyPermanentUpgrade('bullets');
    else applyUpgrade('bullets');
});

document.getElementById('upgrade-speed').addEventListener('click', () => {
    if(isPermanentMenu) applyPermanentUpgrade('speed');
    else applyUpgrade('speed');
});

function resetGame() {
    bulletCount = DEFAULTS.bulletCount + permBulletBonus;
    shootCooldown = DEFAULTS.shootCooldown * permReloadBonus;
    round = DEFAULTS.round;
    zombiesKilled = 0;
    bullets = [];
    enemies = [];
    player.x = canvas.width / 2;
    player.y = canvas.height / 2;
    player.angle = 0;
    ui.style.display = 'none';
    isPermanentMenu = false;
    gameActive = true;
    spawnRound();
}

function applyUpgrade(type) {
    if(type === 'bullets') bulletCount++;
    if(type === 'speed') shootCooldown = Math.max(0, shootCooldown * 0.8);
    ui.style.display = 'none';
    gameActive = true;
    round++;
    spawnRound();
}

function applyPermanentUpgrade(type) {
    if(type === 'bullets') permBulletBonus++;
    if(type === 'speed') permReloadBonus *= 0.85;
    permanentChosen = true;
    ui.style.display = 'none';
    isPermanentMenu = false;
    gameActive = true;
    round++;
    spawnRound();
}

function applyZombiePermanentUpgrade() {
    zombieSpeedBonus += 0.2;
    console.log('ZOMBIE UPGRADE! Speed bonus now: ' + zombieSpeedBonus);
}

function shoot() {
    const now = Date.now();
    if(now - lastShotTime < shootCooldown) return;
    lastShotTime = now;
    
    let baseAngle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    
    // MODIFIED: Higher speed for instant fire, and spread that shrinks as bulletCount grows
    const speed = 20; 
    const spread = 0.2 / bulletCount; 
    
    for(let i = 0; i < bulletCount; i++) {
        // This math centers the cluster on your mouse and uses the new tight spread
        let angle = baseAngle + (i - (bulletCount - 1) / 2) * spread;
        bullets.push({
            x: player.x,
            y: player.y,
            dx: Math.cos(angle) * speed,
            dy: Math.sin(angle) * speed,
            size: 3
        });
    }
}
function spawnRound() {
    enemies = [];
    let count = 5 + round;
    let zSpeed = 0.7 + (round * 0.05) + zombieSpeedBonus;
    
    for(let i = 0; i < count; i++) {
        let safeX, safeY;
        let attempts = 0;
        safeX = 80 + (Math.random() * 60);
        safeY = 80 + (Math.random() * 60);
        
        while((collidesWithWall(safeX, safeY, 18) || safeX < 70 || safeX > 150 || safeY < 70 || safeY > 150) && attempts < 50) {
            safeX = 80 + (Math.random() * 60);
            safeY = 80 + (Math.random() * 60);
            attempts++;
        }
        
        enemies.push({
            x: safeX,
            y: safeY,
            size: 18,
            speed: zSpeed
        });
    }
}

// ---------- FIXED: BULLET UPDATE WITH WALL COLLISION ----------
function update() {
    if(!gameActive) return;
    
    let vx = 0, vy = 0;
    if(keys['w']) vy -= player.speed;
    if(keys['s']) vy += player.speed;
    if(keys['a']) vx -= player.speed;
    if(keys['d']) vx += player.speed;
    
    if(!collidesWithWall(player.x + vx, player.y, player.size)) player.x += vx;
    if(!collidesWithWall(player.x, player.y + vy, player.size)) player.y += vy;
    
    if(vx || vy) player.angle = Math.atan2(vy, vx);
    if(keys[' ']) shoot();
    
    wrapEntity(player);
    
    // **FIXED BULLETS: Check wall collision before updating position**
    for(let i = bullets.length - 1; i >= 0; i--) {
        let b = bullets[i];
        
        // **NEW: Check if bullet will hit wall on next frame**
        if(collidesWithWall(b.x + b.dx, b.y + b.dy, b.size)) {
            bullets.splice(i, 1);
            continue;
        }
        
        // Move bullet
        b.x += b.dx;
        b.y += b.dy;
        
        // Remove bullets that leave screen
        if(b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
            continue;
        }
        
        // Check enemy collision
        for(let j = enemies.length - 1; j >= 0; j--) {
            let e = enemies[j];
            if(Math.hypot(b.x - e.x, b.y - e.y) < (e.size/2 + b.size)) {
                enemies.splice(j, 1);
                bullets.splice(i, 1);
                zombiesKilled++;
                break;
            }
        }
    }
    
    if(enemies.length === 0) {
        if(round % 10 === 0 && round > 0) {
            applyZombiePermanentUpgrade();
        }
        
        if(round === 10 && !permanentChosen) {
            gameActive = false;
            isPermanentMenu = true;
            document.getElementById('menu-title').innerText = 'PERMANENT UPGRADE';
            document.getElementById('menu-text').innerText = 'CHOOSE ONE (KEPT AFTER DEATH)';
            ui.style.display = 'block';
            return;
        }
        if(round % 3 === 0) {
            gameActive = false;
            isPermanentMenu = false;
            document.getElementById('menu-title').innerText = `ROUND ${round} CLEAR`;
            document.getElementById('menu-text').innerText = 'SELECT UPGRADE:';
            ui.style.display = 'block';
        } else {
            round++;
            spawnRound();
        }
    }
    
    enemies.forEach(e => {
        let dx = player.x - e.x;
        let dy = player.y - e.y;
        let dist = Math.hypot(dx, dy) || 1;
        let mx = (dx / dist) * e.speed;
        let my = (dy / dist) * e.speed;
        
        if(!collidesWithWall(e.x + mx, e.y, e.size/2)) e.x += mx;
        if(!collidesWithWall(e.x, e.y + my, e.size/2)) e.y += my;
        
        wrapEntity(e);
        
        if(Math.hypot(player.x - e.x, player.y - e.y) < (e.size/2 + player.size)) {
            resetGame();
        }
    });
}

function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    for(let i = 0; i < canvas.width; i += 50) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, canvas.height);
        ctx.stroke();
    }
    for(let i = 0; i < canvas.height; i += 50) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(canvas.width, i);
        ctx.stroke();
    }
    
    ctx.fillStyle = '#0066CC';
    walls.forEach(w => ctx.fillRect(w.x, w.y, w.width, w.height));
    
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.angle);
    ctx.fillStyle = 'cyan';
    ctx.fillRect(-player.size, -player.size, player.size * 2, player.size * 2);
    ctx.restore();
    
    const charge = Math.min((Date.now() - lastShotTime) / shootCooldown, 1);
    ctx.fillStyle = '#333';
    ctx.fillRect(player.x - 20, player.y + 18, 40, 4);
    ctx.fillStyle = charge === 1 ? '#00ff00' : '#ffaa00';
    ctx.fillRect(player.x - 20, player.y + 18, 40 * charge, 4);
    
    enemies.forEach(e => {
        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.size/2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(e.x - 4, e.y - 2, 2, 0, Math.PI * 2);
        ctx.arc(e.x + 4, e.y - 2, 2, 0, Math.PI * 2);
        ctx.fill();
    });
    
    ctx.fillStyle = '#ffff00';
    bullets.forEach(b => {
        ctx.fillRect(b.x - b.size, b.y - b.size, b.size * 2, b.size * 2);
    });
    
    ctx.fillStyle = 'white';
    ctx.font = 'bold 14px Courier New, monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`ROUND: ${round}`, 20, 30);
    ctx.fillText(`KILLS: ${zombiesKilled}`, 20, 50);
    ctx.fillText(`BULLETS: ${bulletCount}`, 20, 70);
    ctx.fillText(`RELOAD: ${(shootCooldown/1000).toFixed(2)}s`, 20, 90);
    ctx.fillText(`ENEMIES: ${enemies.length}`, 20, 110);
}

// ---------- INIT ----------
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
spawnRound();

function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
